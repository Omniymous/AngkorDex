<html>
<head>
<base href="/">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AngkorDEX - Decentralized Exchange Analytics</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<link rel="stylesheet" href="https://github.com/Omniymous/AngkorDex/blob/main/css/styles.css">
</head>
<body>
<div id="loading-screen">
  <div class="loading-content">
    <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="loading-logo">
      <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
    </svg>
    <h1 class="loading-title">AngkorDEX</h1>
    <div class="loading-spinner"></div>
    <p style="color: var(--secondary); font-size: 1.2rem; margin-bottom: 1rem; text-align: center; animation: fadeIn 0.5s ease;">
      Funded by Angkor VC
    </p>
    <div class="disclaimer">
      &#x26a0;&#xfe0f; RISK DISCLAIMER &#x26a0;&#xfe0f;
      <p>Cryptocurrency trading carries significant risks:</p>
      <ul>
        <li>High volatility and potential loss of capital</li>
        <li>Past performance does not guarantee future results</li>
        <li>Only trade with funds you can afford to lose</li>
        <li>DYOR - Do Your Own Research before trading</li>
      </ul>
    </div>
  </div>
</div>

<nav class="navbar">
  <div class="logo">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
    </svg>
    AngkorDEX
  </div>
  <div class="nav-links">
    <a class="nav-link" onclick="showSection(&apos;main&apos;)">Markets</a>
    <a class="nav-link" onclick="showSection(&apos;staking&apos;)">Staking</a>
    <a class="nav-link" onclick="showSection(&apos;farming&apos;)">Yield Farming</a>
    <a class="nav-link" onclick="showSection(&apos;profile&apos;)">Profile</a>
  </div>
  <div class="search">
    <input type="text" placeholder="Search pairs, tokens...">
  </div>
  <button id="connect-wallet">Connect</button>
</nav>

<div class="ticker-wrap">
  <div class="ticker" id="price-ticker">
  </div>
</div>

<div class="sticky-disclaimer">
  <button class="close-btn" onclick="this.parentElement.style.display=&apos;none&apos;">&#xd7;</button>
  <h4>&#x26a0;&#xfe0f; Trading Risk Warning</h4>
  <p style="color: #fff; margin-bottom: 1rem; font-weight: 500;">
    Before trading, please be aware:
  </p>
  <ul style="list-style: none; padding: 0; margin: 0;">
    <li style="margin-bottom: 0.8rem; color: #fff; display: flex; align-items: center; gap: 0.5rem;">
      <span style="color: #ff4757">&#x2022;</span>
      Cryptocurrency markets are highly volatile
    </li>
    <li style="margin-bottom: 0.8rem; color: #fff; display: flex; align-items: center; gap: 0.5rem;">
      <span style="color: #ff4757">&#x2022;</span>
      Past performance does not guarantee future results
    </li>
    <li style="margin-bottom: 0.8rem; color: #fff; display: flex; align-items: center; gap: 0.5rem;">
      <span style="color: #ff4757">&#x2022;</span>
      Only invest what you can afford to lose
    </li>
    <li style="color: #fff; display: flex; align-items: center; gap: 0.5rem;">
      <span style="color: #ff4757">&#x2022;</span>
      Always do your own research (DYOR)
    </li>
  </ul>
</div>

<main class="main" id="token-container">
</main>

<div id="trade-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--primary); padding: 2rem; border-radius: 10px; z-index: 1000; min-width: 300px;">
  <h2 id="trade-title">Buy/Sell Token</h2>
  <div style="margin: 1rem 0;">
    <label>Amount:</label>
    <input type="number" id="trade-amount" style="width: 100%; padding: 0.5rem; margin-top: 0.5rem; background: var(--bg); color: var(--text); border: 1px solid var(--secondary); border-radius: 5px;">
  </div>
  <div style="display: flex; gap: 1rem; margin-top: 1rem;">
    <button id="confirm-trade" class="buy-btn" style="flex: 1;">Confirm</button>
    <button onclick="closeTradeModal()" class="sell-btn" style="flex: 1;">Cancel</button>
  </div>
</div>

<section id="profile-section" class="profile-section">
  <div class="profile-header">
    <div class="profile-avatar"></div>
    <div>
      <h2>My Profile</h2>
      <p>Wallet: <span id="wallet-address">Not Connected</span></p>
    </div>
  </div>
  <div class="stats">
    <div class="stat-item">
      <small>Total Value Locked</small>
      <div id="tvl">&#x24;0.00</div>
    </div>
    <div class="stat-item">
      <small>Total Earnings</small>
      <div id="earnings">&#x24;0.00</div>
    </div>
  </div>
  <div class="wallet-balance">
    <h3>Wallet Balances</h3>
    <div class="balance-item">
      <span>ETH</span>
      <span class="token-balance" id="eth-balance">0 ETH</span>
    </div>
    <div class="balance-item">
      <span>ANGKOR</span>
      <span class="token-balance" id="angkor-balance">0 ANGKOR</span>
    </div>
    <div class="balance-item">
      <span>USDT</span>
      <span class="token-balance" id="usdt-balance">0 USDT</span>
    </div>
  </div>
</section>

<section id="staking-container" class="staking-container" style="display: none;">
  <div class="staking-card">
    <div class="staking-info">
      <h3>ANGKOR Staking</h3>
      <div class="yield-apr">APR: 12.5%</div>
    </div>
    <div class="stats">
      <div class="stat-item">
        <small>Staked Amount</small>
        <div>0 ANGKOR</div>
      </div>
      <div class="stat-item">
        <small>Earned Rewards</small>
        <div>0 ANGKOR</div>
      </div>
    </div>
    <div class="staking-actions">
      <button class="stake-btn">Stake</button>
      <button class="unstake-btn">Unstake</button>
    </div>
  </div>

  <div class="staking-card">
    <div class="staking-info">
      <h3>ETH-ANGKOR LP Staking</h3>
      <div class="yield-apr">APR: 25%</div>
    </div>
    <div class="stats">
      <div class="stat-item">
        <small>Staked LP</small>
        <div>0 LP</div>
      </div>
      <div class="stat-item">
        <small>Earned Rewards</small>
        <div>0 ANGKOR</div>
      </div>
    </div>
    <div class="staking-actions">
      <button class="stake-btn">Stake LP</button>
      <button class="unstake-btn">Unstake LP</button>
    </div>
  </div>
</section>

<section id="farming-container" class="staking-container" style="display: none;">
  <div class="staking-card">
    <div class="staking-info">
      <h3>ETH-USDT Farm</h3>
      <div class="yield-apr">APR: 35%</div>
    </div>
    <div class="stats">
      <div class="stat-item">
        <small>Deposited</small>
        <div>0 LP</div>
      </div>
      <div class="stat-item">
        <small>Earned</small>
        <div>0 ANGKOR</div>
      </div>
    </div>
    <div class="staking-actions">
      <button class="stake-btn">Deposit</button>
      <button class="unstake-btn">Withdraw</button>
    </div>
  </div>

  <div class="staking-card">
    <div class="staking-info">
      <h3>BTC-ETH Farm</h3>
      <div class="yield-apr">APR: 42%</div>
    </div>
    <div class="stats">
      <div class="stat-item">
        <small>Deposited</small>
        <div>0 LP</div>
      </div>
      <div class="stat-item">
        <small>Earned</small>
        <div>0 ANGKOR</div>
      </div>
    </div>
    <div class="staking-actions">
      <button class="stake-btn">Deposit</button>
      <button class="unstake-btn">Withdraw</button>
    </div>
  </div>
</section>

<div class="data-loading">
  <div class="loading-spinner" style="width: 20px; height: 20px;"></div>
  <span>Updating...</span>
</div>

<script>class SimpleWallet {
  constructor() {
    this.privateKey = null;
    this.address = null;
    this.balance = {
      ETH: 0,
      ANGKOR: 0,
      USDT: 0
    };
    this.initFromStorage();
  }
  initFromStorage() {
    try {
      const encryptedData = localStorage.getItem('walletData');
      if (encryptedData) {
        const decrypted = this.decrypt(encryptedData);
        const data = JSON.parse(decrypted);
        this.privateKey = data.privateKey;
        this.address = data.address;
        this.balance = data.balance;
      }
    } catch (error) {
      console.error('Error loading wallet:', error);
      this.clearWallet();
    }
  }
  generateSecureRandom(length) {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }
  generateWallet() {
    try {
      this.privateKey = '0x' + this.generateSecureRandom(32);
      this.address = '0x' + this.generateSecureRandom(20);
      this.balance = {
        ETH: 0,
        ANGKOR: 1000,
        USDT: 1000
      };
      this.saveWallet();
      return {
        address: this.address,
        privateKey: this.privateKey
      };
    } catch (error) {
      console.error('Error generating wallet:', error);
      throw new Error('Failed to generate secure wallet');
    }
  }
  encrypt(data) {
    const salt = this.generateSecureRandom(16);
    const textToChars = text => text.split('').map(c => c.charCodeAt(0));
    const byteHex = n => ("0" + Number(n).toString(16)).substr(-2);
    const applySaltToChar = code => textToChars(salt).reduce((a, b) => a ^ b, code);
    return salt + textToChars(data).map(applySaltToChar).map(byteHex).join('');
  }
  decrypt(encoded) {
    const salt = encoded.substr(0, 32);
    const textToChars = text => text.split('').map(c => c.charCodeAt(0));
    const applySaltToChar = code => textToChars(salt).reduce((a, b) => a ^ b, code);
    const hexToText = hex => hex.match(/.{1,2}/g).map(hex => parseInt(hex, 16)).map(applySaltToChar).map(charCode => String.fromCharCode(charCode)).join('');
    return hexToText(encoded.substr(32));
  }
  saveWallet() {
    try {
      const data = JSON.stringify({
        privateKey: this.privateKey,
        address: this.address,
        balance: this.balance
      });
      const encrypted = this.encrypt(data);
      localStorage.setItem('walletData', encrypted);
    } catch (error) {
      console.error('Error saving wallet:', error);
      throw new Error('Failed to save wallet securely');
    }
  }
  clearWallet() {
    this.privateKey = null;
    this.address = null;
    this.balance = {
      ETH: 0,
      ANGKOR: 0,
      USDT: 0
    };
    localStorage.removeItem('walletData');
  }
  getAddress() {
    return this.address;
  }
  getBalance(token = 'ETH') {
    return this.balance[token] || 0;
  }
  updateBalance(token, amount) {
    if (amount < 0) throw new Error('Invalid amount');
    if (!this.balance.hasOwnProperty(token)) throw new Error('Invalid token');
    this.balance[token] = parseFloat(amount);
    this.saveWallet();
  }
  send(to, amount, token = 'ETH') {
    if (!this.address) throw new Error('Wallet not initialized');
    if (!amount || amount <= 0) throw new Error('Invalid amount');
    if (this.balance[token] < amount) throw new Error('Insufficient balance');
    const txHash = '0x' + this.generateSecureRandom(32);
    this.balance[token] -= parseFloat(amount);
    this.saveWallet();
    const tx = {
      hash: txHash,
      from: this.address,
      to,
      amount: parseFloat(amount),
      token,
      timestamp: Date.now()
    };
    this.saveTransaction(tx);
    return tx;
  }
  saveTransaction(tx) {
    try {
      const history = JSON.parse(localStorage.getItem('txHistory') || '[]');
      history.push(tx);
      localStorage.setItem('txHistory', JSON.stringify(history));
    } catch (error) {
      console.error('Error saving transaction:', error);
    }
  }
}
const wallet = new SimpleWallet();
let tickerData = [];
const fetchTokenData = async () => {
  try {
    const response = await axios.get('https://api.coingecko.com/api/v3/coins/markets', {
      params: {
        vs_currency: 'usd',
        order: 'market_cap_desc',
        per_page: 250,
        page: 1,
        sparkline: true
      }
    });
    return response.data;
  } catch (error) {
    console.error('Error fetching token data:', error);
    return [];
  }
};
const updateTicker = async () => {
  try {
    if (allTokens.length === 0) {
      allTokens = await fetchTokenData();
    }
    const tickerContainer = document.getElementById('price-ticker');
    tickerData = allTokens.slice(0, 20).map(token => ({
      symbol: token.symbol.toUpperCase(),
      price: token.current_price,
      change: token.price_change_percentage_24h
    }));
    const tickerHTML = tickerData.map(token => {
      const tokenData = allTokens.find(t => t.symbol.toUpperCase() === token.symbol);
      return `
        <div class="ticker-item">
          <img src="${tokenData ? tokenData.image : ''}" alt="${token.symbol}">
          <span>${token.symbol}</span>
          <span>$${token.price.toLocaleString()}</span>
          <span class="${token.change > 0 ? 'green' : 'red'}">
            ${token.change > 0 ? '↑' : '↓'}${Math.abs(token.change).toFixed(2)}%
          </span>
        </div>
      `;
    }).join('');
    tickerContainer.innerHTML = tickerHTML + tickerHTML;
  } catch (error) {
    console.error('Error updating ticker:', error);
  }
};
const checkMetaMaskConnection = () => {
  if (typeof window.ethereum !== 'undefined') {
    return window.ethereum;
  }
  return null;
};
let currentPage = 1;
const tokensPerPage = 100;
let allTokens = [];
const createTokenRow = (tokenData, index) => {
  return `
    <div class="token-row" onclick="openChartModal('${tokenData.id}', '${tokenData.symbol.toUpperCase()}')">
      <div class="token-cell">${(currentPage - 1) * tokensPerPage + index + 1}</div>
      <div class="token-cell">
        <div class="token-info">
          <img class="token-logo" src="${tokenData.image}" alt="${tokenData.symbol}">
          <span>${tokenData.symbol.toUpperCase()}/USD</span>
        </div>
      </div>
      <div class="token-cell">$${tokenData.current_price.toLocaleString()}</div>
      <div class="token-cell ${tokenData.price_change_percentage_24h > 0 ? 'green' : 'red'}">
        ${tokenData.price_change_percentage_24h.toFixed(2)}%
      </div>
      <div class="token-cell">$${(tokenData.total_volume / 1000000).toFixed(2)}M</div>
      <div class="token-cell">$${(tokenData.market_cap / 1000000).toFixed(2)}M</div>
      <div class="token-cell">
        <div class="trade-buttons" onclick="event.stopPropagation()">
          <button class="buy-btn" onclick="openTradeModal('buy', '${tokenData.symbol}', ${tokenData.current_price})">Buy</button>
          <button class="sell-btn" onclick="openTradeModal('sell', '${tokenData.symbol}', ${tokenData.current_price})">Sell</button>
        </div>
      </div>
    </div>
  `;
};
const loadTokenPage = async () => {
  await updateTicker();
  showLoading();
  try {
    const container = document.getElementById('token-container');
    if (allTokens.length === 0) {
      allTokens = await fetchTokenData();
    }
    const startIdx = (currentPage - 1) * tokensPerPage;
    const endIdx = startIdx + tokensPerPage;
    const pageTokens = allTokens.slice(startIdx, endIdx);
    container.innerHTML = `
      <div class="token-list">
        <div class="token-row">
          <div class="token-cell">#</div>
          <div class="token-cell">Token</div>
          <div class="token-cell">Price</div>
          <div class="token-cell">24h Change</div>
          <div class="token-cell">Volume</div>
          <div class="token-cell">Market Cap</div>
          <div class="token-cell">Trade</div>
        </div>
        ${pageTokens.map((token, idx) => createTokenRow(token, idx)).join('')}
      </div>
      <div class="pagination">
        <button class="pagination-btn" onclick="changePage('prev')" ${currentPage === 1 ? 'disabled' : ''}>←</button>
        <span>Page ${currentPage} of ${Math.ceil(allTokens.length / tokensPerPage)}</span>
        <button class="pagination-btn" onclick="changePage('next')" ${currentPage >= Math.ceil(allTokens.length / tokensPerPage) ? 'disabled' : ''}>→</button>
      </div>
    `;
  } finally {
    hideLoading();
  }
};
const changePage = direction => {
  if (direction === 'prev' && currentPage > 1) {
    currentPage--;
  } else if (direction === 'next' && currentPage < Math.ceil(allTokens.length / tokensPerPage)) {
    currentPage++;
  }
  loadTokenPage();
};
const openTradeModal = (type, symbol, price) => {
  if (!wallet.getAddress()) {
    alert('Please connect your wallet first!');
    return;
  }
  const modal = document.getElementById('trade-modal');
  const title = document.getElementById('trade-title');
  const confirmBtn = document.getElementById('confirm-trade');
  title.textContent = `${type.toUpperCase()} ${symbol}`;
  confirmBtn.textContent = `Confirm ${type.toUpperCase()}`;
  confirmBtn.className = type === 'buy' ? 'buy-btn' : 'sell-btn';
  confirmBtn.onclick = () => {
    const amount = document.getElementById('trade-amount').value;
    executeTrade(type, symbol, amount, price);
  };
  modal.style.display = 'block';
};
const closeTradeModal = () => {
  document.getElementById('trade-modal').style.display = 'none';
  document.getElementById('trade-amount').value = '';
};
const executeTrade = async (type, symbol, amount, price) => {
  if (!amount || amount <= 0) {
    alert('Please enter a valid amount');
    return;
  }
  try {
    const total = amount * price;
    if (type === 'buy') {
      wallet.updateBalance('USDT', wallet.getBalance('USDT') - total);
      wallet.updateBalance(symbol, wallet.getBalance(symbol) + parseFloat(amount));
    } else {
      if (wallet.getBalance(symbol) < amount) {
        alert('Insufficient balance');
        return;
      }
      wallet.updateBalance(symbol, wallet.getBalance(symbol) - amount);
      wallet.updateBalance('USDT', wallet.getBalance('USDT') + total);
    }
    updateWalletUI();
    alert(`${type.toUpperCase()} order executed successfully!\n\nToken: ${symbol}\nAmount: ${amount}\nTotal: $${total.toFixed(2)}`);
    closeTradeModal();
  } catch (error) {
    alert(`Trade failed: ${error.message}`);
  }
};
const showSection = sectionId => {
  document.getElementById('token-container').style.display = 'none';
  document.getElementById('profile-section').style.display = 'none';
  document.getElementById('staking-container').style.display = 'none';
  document.getElementById('farming-container').style.display = 'none';
  document.querySelectorAll('.nav-link').forEach(link => {
    link.style.background = 'transparent';
  });
  const clickedLink = Array.from(document.querySelectorAll('.nav-link')).find(link => link.textContent.toLowerCase().includes(sectionId));
  if (clickedLink) {
    clickedLink.style.background = 'rgba(0, 184, 148, 0.1)';
  }
  switch (sectionId) {
    case 'main':
      const container = document.getElementById('token-container');
      container.style.display = 'flex';
      container.style.animation = 'fadeIn 0.3s ease';
      break;
    case 'profile':
      const profile = document.getElementById('profile-section');
      profile.style.display = 'block';
      profile.style.animation = 'fadeIn 0.3s ease';
      break;
    case 'staking':
      const staking = document.getElementById('staking-container');
      staking.style.display = 'grid';
      staking.style.animation = 'fadeIn 0.3s ease';
      break;
    case 'farming':
      const farming = document.getElementById('farming-container');
      farming.style.display = 'grid';
      farming.style.animation = 'fadeIn 0.3s ease';
      break;
  }
};
document.getElementById('connect-wallet').addEventListener('click', async () => {
  try {
    let walletAddress;
    if (typeof window.ethereum !== 'undefined') {
      try {
        const accounts = await ethereum.request({
          method: 'eth_requestAccounts'
        });
        walletAddress = accounts[0];
      } catch (error) {
        console.error('MetaMask connection failed:', error);
        throw new Error('MetaMask connection failed');
      }
    } else {
      if (!wallet.getAddress()) {
        try {
          const newWallet = wallet.generateWallet();
          walletAddress = newWallet.address;
          const confirmed = confirm('IMPORTANT SECURITY NOTICE:\n\n' + '1. This is a demo wallet - DO NOT use for real funds\n' + '2. Store your private key safely and never share it\n' + '3. Your private key will be shown once - save it now\n\n' + 'Show private key?');
          if (confirmed) {
            alert('Wallet Created Successfully!\n\n' + `Address: ${walletAddress}\n\n` + 'PRIVATE KEY (save this securely):\n' + `${newWallet.privateKey}\n\n` + 'WARNING: Never share your private key!');
          }
        } catch (error) {
          console.error('Wallet generation failed:', error);
          throw new Error('Failed to generate secure wallet');
        }
      } else {
        walletAddress = wallet.getAddress();
      }
    }
    const connectBtn = document.getElementById('connect-wallet');
    connectBtn.textContent = `Connected`;
    connectBtn.style.background = '#00b894';
    const addressElem = document.getElementById('wallet-address');
    addressElem.textContent = `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;
    const initial = walletAddress.slice(2, 3).toUpperCase();
    document.querySelector('.profile-avatar').textContent = initial;
    updateWalletUI();
  } catch (error) {
    console.error('Wallet connection error:', error);
    alert(`Failed to connect wallet: ${error.message}`);
  }
});
function updateWalletUI() {
  const ethBalance = wallet.getBalance('ETH');
  const angkorBalance = wallet.getBalance('ANGKOR');
  const usdtBalance = wallet.getBalance('USDT');
  const ethValue = ethBalance * 1800;
  const angkorValue = angkorBalance * 2;
  const usdtValue = usdtBalance * 1;
  const totalValue = ethValue + angkorValue + usdtValue;
  document.getElementById('tvl').textContent = `$${totalValue.toFixed(2)}`;
  document.getElementById('earnings').textContent = `$${(totalValue * 0.1).toFixed(2)}`;
  document.getElementById('eth-balance').textContent = `${ethBalance.toFixed(4)} ETH`;
  document.getElementById('angkor-balance').textContent = `${angkorBalance.toFixed(2)} ANGKOR`;
  document.getElementById('usdt-balance').textContent = `${usdtBalance.toFixed(2)} USDT`;
  const addressElem = document.getElementById('wallet-address');
  if (wallet.getAddress()) {
    addressElem.textContent = `${wallet.getAddress().slice(0, 6)}...${wallet.getAddress().slice(-4)}`;
  } else {
    addressElem.textContent = 'Not Connected';
  }
}
document.addEventListener('DOMContentLoaded', async () => {
  showSection('main');
  await loadTokenPage();
  const loadingScreen = document.getElementById('loading-screen');
  loadingScreen.style.transition = 'opacity 0.5s ease-out';
  setTimeout(() => {
    loadingScreen.style.opacity = '0';
    setTimeout(() => {
      loadingScreen.style.display = 'none';
    }, 500);
  }, 2000);
  updateTicker();
  setInterval(updateTicker, 60000);
  window.addEventListener('resize', () => {
    if (priceChart) {
      priceChart.resize();
    }
  });
});
let searchTimeout;
document.querySelector('.search input').addEventListener('input', e => {
  clearTimeout(searchTimeout);
  const searchBar = e.target;
  if (searchBar.value) {
    searchBar.style.boxShadow = '0 0 0 3px rgba(0, 184, 148, 0.3)';
  } else {
    searchBar.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
  }
  searchTimeout = setTimeout(() => {
    const searchTerm = searchBar.value.toLowerCase();
    const rows = document.querySelectorAll('.token-row:not(:first-child)');
    rows.forEach(row => {
      if (row.querySelector('.token-info')) {
        const token = row.querySelector('.token-info').textContent.toLowerCase();
        if (token.includes(searchTerm)) {
          row.style.display = 'table-row';
          row.style.animation = 'highlightRow 0.5s ease';
        } else {
          row.style.display = 'none';
        }
      }
    });
  }, 300);
});
document.addEventListener('touchstart', () => {}, {
  passive: true
});
let touchStart = 0;
document.addEventListener('touchstart', e => {
  touchStart = e.touches[0].pageY;
}, {
  passive: true
});
document.addEventListener('touchmove', e => {
  const touchEnd = e.touches[0].pageY;
  if (touchEnd - touchStart > 100 && window.scrollY === 0) {
    loadTokenPage();
  }
}, {
  passive: true
});
setInterval(async () => {
  showLoading();
  try {
    allTokens = await fetchTokenData();
    await loadTokenPage();
  } finally {
    hideLoading();
  }
}, 60000);
const showLoading = () => {
  const loader = document.querySelector('.data-loading');
  loader.classList.add('visible');
};
const hideLoading = () => {
  const loader = document.querySelector('.data-loading');
  loader.classList.remove('visible');
};
document.querySelectorAll('.stake-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const ethereum = checkMetaMaskConnection();
    if (!ethereum || !ethereum.selectedAddress) {
      alert('Please connect your wallet first!');
      return;
    }
    alert('Staking feature coming soon!');
  });
});
document.querySelectorAll('.unstake-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const ethereum = checkMetaMaskConnection();
    if (!ethereum || !ethereum.selectedAddress) {
      alert('Please connect your wallet first!');
      return;
    }
    alert('Unstaking feature coming soon!');
  });
});
let priceChart = null;
const openChartModal = async (coinId, symbol) => {
  let modal = document.getElementById('chart-modal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'chart-modal';
    modal.style.cssText = `
      display: none; 
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 2rem;
      border-radius: 10px;
      z-index: 1000;
      width: 80%;
      max-width: 1000px;
      height: 600px;
    `;
    modal.innerHTML = `
      <div class="chart-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h2 id="chart-title" style="color: var(--secondary);"></h2>
        <button onclick="closeChartModal()" style="background: none; border: none; color: var(--text); font-size: 1.5rem; cursor: pointer;">×</button>
      </div>
      <div class="chart-container">
        <canvas id="price-chart"></canvas>
      </div>
    `;
    document.body.appendChild(modal);
    const header = modal.querySelector('.chart-header');
    header.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);
    header.addEventListener('touchstart', dragStart);
    document.addEventListener('touchmove', drag);
    document.addEventListener('touchend', dragEnd);
  }
  xOffset = 0;
  yOffset = 0;
  modal.style.transform = 'translate(-50%, -50%)';
  const titleElement = modal.querySelector('#chart-title');
  const canvas = modal.querySelector('#price-chart');
  titleElement.textContent = `${symbol} Price Chart`;
  modal.style.display = 'block';
  try {
    showLoading();
    const response = await axios.get(`https://api.coingecko.com/api/v3/coins/${coinId}/market_chart`, {
      params: {
        vs_currency: 'usd',
        days: 30
      }
    });
    const prices = response.data.prices;
    const labels = prices.map(p => new Date(p[0]).toLocaleDateString());
    const data = prices.map(p => p[1]);
    if (priceChart) {
      priceChart.destroy();
    }
    const ctx = canvas.getContext('2d');
    priceChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          label: `${symbol} Price USD`,
          data: data,
          borderColor: '#00f3ff',
          borderWidth: 2,
          fill: true,
          backgroundColor: 'rgba(0, 243, 255, 0.1)',
          tension: 0.4,
          pointRadius: 0,
          pointHitRadius: 20
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          intersect: false,
          mode: 'index'
        },
        plugins: {
          legend: {
            labels: {
              color: '#fff'
            }
          },
          tooltip: {
            mode: 'index',
            intersect: false,
            backgroundColor: 'rgba(0,0,0,0.8)',
            borderColor: 'var(--secondary)',
            borderWidth: 1
          }
        },
        scales: {
          x: {
            grid: {
              color: 'rgba(255,255,255,0.1)'
            },
            ticks: {
              color: '#fff'
            }
          },
          y: {
            grid: {
              color: 'rgba(255,255,255,0.1)'
            },
            ticks: {
              color: '#fff',
              callback: function (value) {
                return '$' + value.toFixed(2);
              }
            }
          }
        }
      }
    });
  } catch (error) {
    console.error('Error loading chart data:', error);
    alert('Failed to load chart data');
    modal.style.display = 'none';
  } finally {
    hideLoading();
  }
};
const closeChartModal = () => {
  const modal = document.getElementById('chart-modal');
  if (modal) {
    modal.style.display = 'none';
  }
  if (priceChart) {
    priceChart.destroy();
    priceChart = null;
  }
  xOffset = 0;
  yOffset = 0;
};
let isDragging = false;
let currentX;
let currentY;
let initialX;
let initialY;
let xOffset = 0;
let yOffset = 0;
function dragStart(e) {
  const modal = document.getElementById('chart-modal');
  const rect = modal.getBoundingClientRect();
  if (e.type === "touchstart") {
    initialX = e.touches[0].clientX - xOffset;
    initialY = e.touches[0].clientY - yOffset;
  } else {
    initialX = e.clientX - xOffset;
    initialY = e.clientY - yOffset;
  }
  if (e.target.classList.contains('chart-header')) {
    isDragging = true;
  }
}
function drag(e) {
  if (isDragging) {
    e.preventDefault();
    const modal = document.getElementById('chart-modal');
    if (e.type === "touchmove") {
      currentX = e.touches[0].clientX - initialX;
      currentY = e.touches[0].clientY - initialY;
    } else {
      currentX = e.clientX - initialX;
      currentY = e.clientY - initialY;
    }
    xOffset = currentX;
    yOffset = currentY;
    modal.style.transform = `translate(calc(-50% + ${currentX}px), calc(-50% + ${currentY}px))`;
  }
}
function dragEnd() {
  initialX = currentX;
  initialY = currentY;
  isDragging = false;
}</script>
</body>
</html>
